'use client'

import React, { useState, useMemo, useRef, useCallback, useEffect } from 'react'
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  BarElement,
  LineElement,
  PointElement,
  Title,
  Tooltip,
  Legend,
  ChartOptions,
  InteractionItem,
  ChartEvent
} from 'chart.js'
import { Bar, getElementAtEvent } from 'react-chartjs-2'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import { Calendar } from '@/components/ui/calendar'
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover'
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogPortal, DialogOverlay } from '@/components/ui/dialog'
import * as DialogPrimitive from '@radix-ui/react-dialog'
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/components/ui/collapsible'
import { cn } from '@/lib/utils/index'
import { CalendarIcon, Clock, TrendingUp, TrendingDown, Eye, X, Zap, Target, Award, ChevronRight, Sprout } from 'lucide-react'
import { format, addMonths, subMonths } from 'date-fns'
import { ja } from 'date-fns/locale'
import { createClient } from '@supabase/supabase-js'
import type { Database, WeatherRecord } from '@/types/database'

// Chart.jsの登録
ChartJS.register(
  CategoryScale,
  LinearScale,
  BarElement,
  LineElement,
  PointElement,
  Title,
  Tooltip,
  Legend
)

interface WorkHoursData {
  month: string
  year: number
  month_num: number
  work_types: {
    [key: string]: {
      total_hours: number
      revenue_per_hour: number
      cost_per_hour: number
      roi_per_hour: number
      efficiency_score: number
      work_count: number
      details: WorkDetail[]
    }
  }
  monthly_total_hours: number
  monthly_avg_efficiency: number
  monthly_total_revenue: number
  monthly_total_cost: number
  // 🌡️💧 気象データ追加
  weather_data?: {
    temperature: number  // 平均気温（°C）
    humidity: number     // 平均湿度（%）
    temperature_range: {
      min: number
      max: number
    }
    humidity_range: {
      min: number
      max: number
    }
  }
  ai_predictions?: {
    predicted_hours: number
    efficiency_trend: 'improving' | 'stable' | 'declining'
    optimization_score: number
    suggestions: string[]
  }
  benchmarks?: {
    industry_average_hours: number
    top_performers_hours: number
    efficiency_percentile: number
  }
}

interface WorkDetail {
  id: string
  work_type: string
  work_date: string
  duration_hours: number
  revenue_generated: number
  cost_incurred: number
  efficiency_rating: 'excellent' | 'good' | 'average' | 'poor'
  description?: string
}

interface MonthlyWorkHoursChartProps {
  companyId: string
  selectedVegetable?: string
}

// 🌡️💧 気象データ表示オプション
interface WeatherDisplayOptions {
  showTemperature: boolean
  showHumidity: boolean
}

// 作業種別の色定義（AI効率×ROI最適化テーマ）
const WORK_TYPE_COLORS = {
  seeding: '#6366f1',      // インディゴ - 播種（計画性）
  planting: '#8b5cf6',     // バイオレット - 定植（実行力）
  fertilizing: '#f59e0b',  // アンバー - 施肥（投資効果）
  watering: '#06b6d4',     // シアン - 灌水（持続性）
  weeding: '#ef4444',      // レッド - 除草（効率性）
  pruning: '#a855f7',      // パープル - 整枝（精密性）
  harvesting: '#10b981',   // エメラルド - 収穫（収益性）
  other: '#6b7280'         // グレー - その他
}

const WORK_TYPE_LABELS = {
  seeding: '播種',
  planting: '定植', 
  fertilizing: '施肥',
  watering: '灌水',
  weeding: '除草',
  pruning: '整枝',
  harvesting: '収穫',
  other: 'その他'
}

// レスポンシブ寸法計算の型定義
interface ResponsiveDimensions {
  monthCount: number
  barWidth: number
  categoryPercentage: number
  barPercentage: number
  fontSize: number
  labelRotation: number
}

// カスタムLargeDialogContent
interface LargeDialogContentProps extends React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content> {
  width?: string
  height?: string
  children?: React.ReactNode
  title?: string
}

function LargeDialogContent({
  className,
  children,
  width = "1200px",
  height = "900px",
  title = "作業時間詳細分析",
  ...props
}: LargeDialogContentProps) {
  return (
    <DialogPortal>
      <DialogOverlay />
      <DialogPrimitive.Content
        className={cn(
          "fixed top-[50%] left-[50%] z-50 translate-x-[-50%] translate-y-[-50%]",
          "data-[state=open]:animate-in data-[state=closed]:animate-out",
          "data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
          "data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95",
          "grid gap-4 rounded-lg border p-6 shadow-lg duration-200",
          "bg-white border-gray-300 shadow-xl overflow-auto",
          className
        )}
        style={{ 
          width, 
          height, 
          maxWidth: '98vw', 
          maxHeight: '98vh' 
        }}
        {...props}
      >
        <DialogPrimitive.Title className="sr-only">
          {title}
        </DialogPrimitive.Title>
        {children}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

export default function MonthlyWorkHoursChart({ companyId, selectedVegetable = 'all' }: MonthlyWorkHoursChartProps) {
  // Supabaseクライアント初期化
  const supabase = createClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
  const [startMonth, setStartMonth] = useState<Date>(new Date(new Date().getFullYear(), 0, 1))
  const [calendarOpen, setCalendarOpen] = useState(false)
  const [yearMonthPickerOpen, setYearMonthPickerOpen] = useState(false)
  const [selectedYear, setSelectedYear] = useState<number>(new Date().getFullYear())
  const [selectedMonthNum, setSelectedMonthNum] = useState<number>(1)
  const [displayPeriod, setDisplayPeriod] = useState<1 | 2 | 3>(1)
  const [workHoursData, setWorkHoursData] = useState<WorkHoursData[]>([])
  const [previousYearData, setPreviousYearData] = useState<WorkHoursData[]>([])
  const [loading, setLoading] = useState(false)
  const [selectedMonth, setSelectedMonth] = useState<WorkHoursData | null>(null)
  const [drilldownOpen, setDrilldownOpen] = useState(false)
  const [showComparison, setShowComparison] = useState(true)
  const [showAIInsights, setShowAIInsights] = useState(true)
  // 累積作業時間線の制御状態
  const [showCumulativeWorkTime, setShowCumulativeWorkTime] = useState(true)
  const [containerWidth, setContainerWidth] = useState(0)
  const [lastUpdated, setLastUpdated] = useState(new Date())
  // 作業種別・期間合計時間の展開状態
  const [isWorkTypeTotalsOpen, setIsWorkTypeTotalsOpen] = useState(true)
  
  // 🌡️💧 気象データ表示状態
  const [weatherDisplayOptions, setWeatherDisplayOptions] = useState<WeatherDisplayOptions>({
    showTemperature: false,
    showHumidity: false
  })
  
  const chartRef = useRef<ChartJS<'bar'>>(null)
  const containerRef = useRef<HTMLDivElement>(null)
  const [chartDimensions, setChartDimensions] = useState({ left: 0, right: 0, width: 0 })

  // レスポンシブ寸法計算
  const calculateResponsiveDimensions = useCallback((period: number, containerWidth: number): ResponsiveDimensions => {
    const monthCount = period * 12
    const availableWidth = containerWidth - 90
    const idealBarWidth = availableWidth / monthCount
    
    const barWidth = Math.max(25, Math.min(80, idealBarWidth))
    const categoryPercentage = barWidth > 50 ? 0.9 : 0.95
    const barPercentage = barWidth > 50 ? 0.8 : barWidth > 35 ? 0.85 : 0.9
    const fontSize = barWidth > 50 ? 12 : barWidth > 35 ? 11 : 10
    const labelRotation = barWidth < 40 ? 45 : 0
    
    return {
      monthCount,
      barWidth,
      categoryPercentage,
      barPercentage,
      fontSize,
      labelRotation
    }
  }, [])

  // コンテナ幅の監視
  useEffect(() => {
    const updateContainerWidth = () => {
      if (containerRef.current) {
        setContainerWidth(containerRef.current.offsetWidth)
      }
    }

    updateContainerWidth()
    window.addEventListener('resize', updateContainerWidth)
    return () => window.removeEventListener('resize', updateContainerWidth)
  }, [])

  // レスポンシブ設定の計算
  const responsiveDimensions = useMemo(() => 
    calculateResponsiveDimensions(displayPeriod, containerWidth), 
    [displayPeriod, containerWidth, calculateResponsiveDimensions]
  )

  // Y軸範囲の動的計算（大規模データ対応版）
  const calculateYAxisRange = useCallback((data: WorkHoursData[]) => {
    if (!data || data.length === 0) return {
      min: 0,
      max: 100,
      stepSize: 20,
      tickCount: 6,
      unit: 'hours',
      unitDivisor: 1,
      unitLabel: '時間'
    }

    const allValues = data.map(d => d.monthly_total_hours)
    const rawMax = Math.max(...allValues, 10)

    // 上部に20%の余裕を持たせる
    let targetMax = rawMax * 1.2

    // 単位の自動選択（読みやすさを重視）
    let unit = 'hours'
    let unitDivisor = 1
    let unitLabel = '時間'

    if (targetMax >= 50000) {
      // 5万時間以上は「万時間」表示
      unit = 'man'
      unitDivisor = 10000
      unitLabel = '万時間'
      targetMax = targetMax / 10000
    } else if (targetMax >= 5000) {
      // 5千時間以上は「千時間」表示
      unit = 'sen'
      unitDivisor = 1000
      unitLabel = '千時間'
      targetMax = targetMax / 1000
    }

    // 単位変換後の最適なステップサイズ候補
    const niceSteps = [
      0.1, 0.2, 0.25, 0.5,
      1, 2, 2.5, 5,
      10, 20, 25, 50,
      100, 200, 250, 500,
      1000, 2000, 2500, 5000,
      10000, 20000, 25000, 50000,
      100000
    ]

    // 5〜8個の目盛りになる最適なステップを見つける
    let bestOption = { stepSize: 1, tickCount: 6, max: 6 }
    let minDiff = Infinity

    for (const step of niceSteps) {
      // 5〜8個の範囲で試す
      for (let ticks = 5; ticks <= 8; ticks++) {
        const candidateMax = step * (ticks - 1)
        if (candidateMax >= targetMax) {
          const diff = candidateMax - targetMax
          if (diff < minDiff) {
            minDiff = diff
            bestOption = {
              stepSize: step,
              tickCount: ticks,
              max: candidateMax
            }
          }
        }
      }
    }

    // フォールバック処理
    if (bestOption.max < targetMax) {
      const targetTicks = 6
      const rawStep = targetMax / (targetTicks - 1)
      const step = niceSteps.find(s => s >= rawStep) || rawStep
      bestOption = {
        stepSize: Math.ceil(step),
        tickCount: targetTicks,
        max: Math.ceil(step) * (targetTicks - 1)
      }
    }

    return {
      min: 0,
      max: bestOption.max,
      stepSize: bestOption.stepSize,
      tickCount: bestOption.tickCount,
      unit,
      unitDivisor,
      unitLabel
    }
  }, [])

  // 🌡️💧 Supabaseから気象データを取得（work_reportsテーブルから）
  const fetchWeatherData = useCallback(async (month: Date): Promise<WorkHoursData['weather_data']> => {
    try {
      const startOfMonth = new Date(month.getFullYear(), month.getMonth(), 1)
      const endOfMonth = new Date(month.getFullYear(), month.getMonth() + 1, 0)
      
      const { data: weatherRecords, error } = await supabase
        .from('work_reports')
        .select('temperature, humidity')
        .eq('company_id', companyId)
        .gte('work_date', startOfMonth.toISOString().split('T')[0])
        .lte('work_date', endOfMonth.toISOString().split('T')[0])
        .not('temperature', 'is', null)
        .not('humidity', 'is', null)

      if (error) {
        // テーブルが存在しない場合などは静かに無視
        console.warn('気象データテーブルが存在しないか、データが取得できませんでした')
        return null
      }

      if (!weatherRecords || weatherRecords.length === 0) {
        // データがない場合はnullを返す
        return null
      }

      // 有効なデータのみをフィルタリング（0や空値を除外）
      const validRecords = weatherRecords.filter(record => 
        record.temperature && record.temperature > 0 && 
        record.humidity && record.humidity > 0
      )

      if (validRecords.length === 0) {
        // 有効なデータがない場合はnullを返す
        return null
      }

      // 月平均値を計算
      const avgTemp = validRecords.reduce((sum, record) => sum + record.temperature, 0) / validRecords.length
      const avgHumidity = validRecords.reduce((sum, record) => sum + record.humidity, 0) / validRecords.length
      const minTemp = Math.min(...validRecords.map(r => r.temperature))
      const maxTemp = Math.max(...validRecords.map(r => r.temperature))
      const minHumidity = Math.min(...validRecords.map(r => r.humidity))
      const maxHumidity = Math.max(...validRecords.map(r => r.humidity))

      return {
        temperature: Math.round(avgTemp * 10) / 10,
        humidity: Math.round(avgHumidity),
        temperature_range: {
          min: isFinite(minTemp) ? Math.round(minTemp * 10) / 10 : avgTemp - 5,
          max: isFinite(maxTemp) ? Math.round(maxTemp * 10) / 10 : avgTemp + 5
        },
        humidity_range: {
          min: isFinite(minHumidity) ? minHumidity : Math.max(0, avgHumidity - 10),
          max: isFinite(maxHumidity) ? maxHumidity : Math.min(100, avgHumidity + 10)
        }
      }
    } catch (error) {
      // ネットワークエラーや予期しないエラーは静かに無視
      console.warn('気象データ取得時にエラーが発生しました:', error)
      return null
    }
  }, [companyId, supabase])

  // AI予測アルゴリズム（簡易実装）
  const generateAIPredictions = (monthData: any[], workReports: any[]): WorkHoursData['ai_predictions'] => {
    if (workReports.length === 0) return undefined

    // 平均作業時間を計算
    const totalHours = workReports.reduce((sum: number, r: any) => sum + (r.duration_hours || 2), 0)
    const avgEfficiency = workReports.reduce((sum: number, r: any) => {
      const revenue = (r.harvest_amount || 0) * (r.expected_price || 0)
      const cost = r.estimated_cost || (r.duration_hours || 2) * 1000 // 時給1000円想定
      return sum + (cost > 0 ? revenue / cost : 0)
    }, 0) / workReports.length

    // トレンド分析（簡易）
    let trend: 'improving' | 'stable' | 'declining' = 'stable'
    if (avgEfficiency > 1.2) trend = 'improving'
    else if (avgEfficiency < 0.8) trend = 'declining'

    // 最適化スコア計算
    const optimizationScore = Math.min(100, Math.max(0, avgEfficiency * 50))

    // AI提案生成
    const suggestions = []
    if (avgEfficiency < 1.0) {
      suggestions.push('作業効率の改善が推奨されます。作業手順の見直しを検討してください。')
    }
    if (totalHours > 200) {
      suggestions.push('月間作業時間が多めです。作業分散や効率化ツールの導入を検討してください。')
    }
    if (trend === 'declining') {
      suggestions.push('効率性の低下傾向が見られます。原因分析と対策が必要です。')
    }
    
    return {
      predicted_hours: totalHours * 1.1, // 10%増を予測
      efficiency_trend: trend,
      optimization_score: Math.round(optimizationScore),
      suggestions
    }
  }

  // ベンチマーク計算（業界平均など）
  const generateBenchmarks = (totalHours: number): WorkHoursData['benchmarks'] => {
    // 仮の業界データ（実際は外部APIやDBから取得）
    return {
      industry_average_hours: 180, // 月間180時間を業界平均と仮定
      top_performers_hours: 150,   // トップパフォーマー150時間
      efficiency_percentile: totalHours <= 150 ? 90 : totalHours <= 180 ? 70 : totalHours <= 220 ? 50 : 25
    }
  }

  // データフェッチ
  const fetchWorkHoursData = useCallback(async () => {
    if (!companyId) return
    
    setLoading(true)
    try {
      console.log('⏰ 作業時間データ取得開始:', companyId)
      
      const endMonth = addMonths(startMonth, responsiveDimensions.monthCount - 1)
      const startDate = format(startMonth, 'yyyy-MM-01')
      const endDate = format(endMonth, 'yyyy-MM-dd')
      
      let apiUrl = `/api/reports?company_id=${companyId}&start_date=${startDate}&end_date=${endDate}&limit=1000`
      if (selectedVegetable && selectedVegetable !== 'all') {
        apiUrl += `&vegetable_id=${selectedVegetable}`
      }
      
      // 前年同期のデータも取得
      const previousYearStart = format(subMonths(startMonth, 12), 'yyyy-MM-01')
      const previousYearEnd = format(subMonths(endMonth, 12), 'yyyy-MM-dd')
      let previousYearApiUrl = `/api/reports?company_id=${companyId}&start_date=${previousYearStart}&end_date=${previousYearEnd}&limit=1000`
      if (selectedVegetable && selectedVegetable !== 'all') {
        previousYearApiUrl += `&vegetable_id=${selectedVegetable}`
      }
      
      const [reportsResponse, previousYearResponse] = await Promise.all([
        fetch(apiUrl),
        fetch(previousYearApiUrl)
      ])
      
      if (!reportsResponse.ok) {
        throw new Error('データの取得に失敗しました')
      }
      
      const reportsResult = await reportsResponse.json()
      const reports = reportsResult.success ? reportsResult.data : []
      
      const previousYearResult = previousYearResponse.ok ? await previousYearResponse.json() : { success: false, data: [] }
      const previousYearReports = previousYearResult.success ? previousYearResult.data : []
      
      console.log('⏰ 作業時間: フィルター適用', {
        選択野菜: selectedVegetable,
        取得レポート数: reports.length,
        前年レポート数: previousYearReports.length
      })
      
      // 月次作業時間データを生成
      const monthlyData: WorkHoursData[] = []
      const previousMonthlyData: WorkHoursData[] = []
      
      for (let i = 0; i < responsiveDimensions.monthCount; i++) {
        const currentMonth = addMonths(startMonth, i)
        const monthKey = format(currentMonth, 'yyyy-MM')
        const monthReports = reports.filter((r: any) => 
          r.work_date.startsWith(monthKey)
        )
        
        const workTypes: any = {}
        let monthlyTotalHours = 0
        let monthlyTotalRevenue = 0
        let monthlyTotalCost = 0
        
        // 作業種別ごとにデータを集計
        Object.keys(WORK_TYPE_COLORS).forEach(workType => {
          const typeReports = monthReports.filter((r: any) => r.work_type === workType)
          
          // work_duration(分) または duration_hours(時) × worker_count で総作業時間を計算
          const totalHours = typeReports.reduce((sum: number, r: any) => {
            // work_duration（分）を優先、なければduration_hoursを使用
            const minutes = r.work_duration || (r.duration_hours ? r.duration_hours * 60 : 0)
            const workers = r.worker_count || 1
            return sum + (minutes * workers) / 60 // 時間単位に変換
          }, 0)
          const totalRevenue = typeReports.reduce((sum: number, r: any) => {
            if (workType === 'harvesting') {
              return sum + ((r.harvest_amount || 0) * (r.expected_price || 0))
            }
            return sum + (r.expected_revenue || 0)
          }, 0)
          
          // コスト計算（会計データも考慮）
          const directCosts = typeReports.reduce((sum: number, r: any) => sum + (r.estimated_cost || (r.duration_hours || 2) * 1000), 0)
          const accountingCosts = typeReports.reduce((sum: number, r: any) => {
            if (r.work_report_accounting && Array.isArray(r.work_report_accounting)) {
              return sum + r.work_report_accounting.reduce((accSum: number, acc: any) => accSum + (acc.amount || 0), 0)
            }
            return sum
          }, 0)
          const totalCost = Math.max(directCosts, accountingCosts)
          
          // 効率性指標計算
          const revenuePerHour = totalHours > 0 ? totalRevenue / totalHours : 0
          const costPerHour = totalHours > 0 ? totalCost / totalHours : 0
          const roiPerHour = costPerHour > 0 ? (revenuePerHour - costPerHour) / costPerHour : 0
          const efficiencyScore = Math.min(100, Math.max(0, roiPerHour * 50 + 50))
          
          workTypes[workType] = {
            total_hours: totalHours,
            revenue_per_hour: revenuePerHour,
            cost_per_hour: costPerHour,
            roi_per_hour: roiPerHour,
            efficiency_score: efficiencyScore,
            work_count: typeReports.length,
            details: typeReports.map((r: any) => ({
              id: r.id,
              work_type: r.work_type,
              work_date: r.work_date,
              // work_duration(分) または duration_hours(時) × worker_count
              duration_hours: (() => {
                const minutes = r.work_duration || (r.duration_hours ? r.duration_hours * 60 : 0)
                const workers = r.worker_count || 1
                return (minutes * workers) / 60 // 時間単位に変換
              })(),
              revenue_generated: workType === 'harvesting' ? 
                (r.harvest_amount || 0) * (r.expected_price || 0) : 
                (r.expected_revenue || 0),
              cost_incurred: Math.max(r.estimated_cost || (r.duration_hours || 2) * 1000, 
                (r.work_report_accounting?.reduce((sum: number, acc: any) => sum + (acc.amount || 0), 0)) || 0),
              efficiency_rating: efficiencyScore > 80 ? 'excellent' as const : 
                               efficiencyScore > 60 ? 'good' as const : 
                               efficiencyScore > 40 ? 'average' as const : 'poor' as const,
              description: r.description || r.notes
            }))
          }
          
          monthlyTotalHours += totalHours
          monthlyTotalRevenue += totalRevenue
          monthlyTotalCost += totalCost
        })
        
        const avgEfficiency = Object.values(workTypes).reduce((sum: any, wt: any) => sum + wt.efficiency_score, 0) / Object.keys(workTypes).length
        const aiPredictions = generateAIPredictions(monthlyData, monthReports)
        const benchmarks = generateBenchmarks(monthlyTotalHours)
        
        // 🌡️💧 Supabaseから気象データを取得
        const weatherData = await fetchWeatherData(currentMonth)
        
        monthlyData.push({
          month: format(currentMonth, 'M月', { locale: ja }),
          year: currentMonth.getFullYear(),
          month_num: currentMonth.getMonth() + 1,
          work_types: workTypes,
          monthly_total_hours: monthlyTotalHours,
          monthly_avg_efficiency: avgEfficiency,
          monthly_total_revenue: monthlyTotalRevenue,
          monthly_total_cost: monthlyTotalCost,
          weather_data: weatherData,
          ai_predictions: aiPredictions,
          benchmarks: benchmarks
        })
      }
      
      // 前年データも同様に処理（簡略版）
      for (let i = 0; i < responsiveDimensions.monthCount; i++) {
        const currentMonth = addMonths(startMonth, i)
        const previousMonth = subMonths(currentMonth, 12)
        const monthKey = format(previousMonth, 'yyyy-MM')
        const prevMonthReports = previousYearReports.filter((r: any) => 
          r.work_date.startsWith(monthKey)
        )
        
        const workTypes: any = {}
        let monthlyTotalHours = 0
        
        Object.keys(WORK_TYPE_COLORS).forEach(workType => {
          const typeReports = prevMonthReports.filter((r: any) => r.work_type === workType)
          // work_duration(分) または duration_hours(時) × worker_count で総作業時間を計算
          const totalHours = typeReports.reduce((sum: number, r: any) => {
            // work_duration（分）を優先、なければduration_hoursを使用
            const minutes = r.work_duration || (r.duration_hours ? r.duration_hours * 60 : 0)
            const workers = r.worker_count || 1
            return sum + (minutes * workers) / 60 // 時間単位に変換
          }, 0)
          
          workTypes[workType] = {
            total_hours: totalHours,
            revenue_per_hour: 0,
            cost_per_hour: 0,
            roi_per_hour: 0,
            efficiency_score: 0,
            work_count: typeReports.length,
            details: []
          }
          
          monthlyTotalHours += totalHours
        })
        
        // 🌡️💧 前年の気象データも取得
        const previousYearMonth = new Date(currentMonth.getFullYear() - 1, currentMonth.getMonth(), currentMonth.getDate())
        const previousWeatherData = await fetchWeatherData(previousYearMonth)
        
        previousMonthlyData.push({
          month: format(currentMonth, 'M月', { locale: ja }),
          year: currentMonth.getFullYear(),
          month_num: currentMonth.getMonth() + 1,
          work_types: workTypes,
          monthly_total_hours: monthlyTotalHours,
          monthly_avg_efficiency: 0,
          monthly_total_revenue: 0,
          monthly_total_cost: 0,
          weather_data: previousWeatherData
        })
      }
      
      setWorkHoursData(monthlyData)
      setPreviousYearData(previousMonthlyData)
      setLastUpdated(new Date())
      console.log('✅ 作業時間データ生成完了:', monthlyData.length, '件')
      
    } catch (error) {
      console.error('❌ 作業時間データ取得エラー:', error)
      setWorkHoursData([])
    } finally {
      setLoading(false)
    }
  }, [companyId, startMonth, selectedVegetable, responsiveDimensions])

  // データフェッチ実行
  React.useEffect(() => {
    if (companyId) {
      fetchWorkHoursData()
    }
  }, [fetchWorkHoursData, companyId])

  // チャートデータの準備
  const chartData = useMemo(() => {
    if (!workHoursData || workHoursData.length === 0) return null

    const workTypes = Object.keys(WORK_TYPE_COLORS)
    const datasets = workTypes.map(workType => {
      // Y軸の単位に応じてデータを変換
      const hoursData = workHoursData.map(d => {
        const hours = d.work_types[workType]?.total_hours || 0
        return hours / yAxisRange.unitDivisor
      })

      return {
        label: `${WORK_TYPE_LABELS[workType as keyof typeof WORK_TYPE_LABELS]}`,
        data: hoursData,
        backgroundColor: WORK_TYPE_COLORS[workType as keyof typeof WORK_TYPE_COLORS],
        borderColor: WORK_TYPE_COLORS[workType as keyof typeof WORK_TYPE_COLORS],
        borderWidth: 1,
        stack: 'hours',
        type: 'bar' as const,
        yAxisID: 'y',
        order: 1
      }
    })
    
    // 🌡️💧 気象データのライン追加（ユーザー選択に応じて）
    if (weatherDisplayOptions.showTemperature) {
      datasets.push({
        label: '気温 (°C)',
        data: workHoursData.map(d => {
          // 有効な気象データがある場合のみプロット
          return (d.weather_data?.temperature && d.weather_data.temperature > 0) 
            ? d.weather_data.temperature 
            : null
        }),
        borderColor: '#f97316', // オレンジ色
        backgroundColor: 'rgba(249, 115, 22, 0.1)',
        fill: false,
        tension: 0.4,
        pointRadius: 6,
        pointHoverRadius: 8,
        pointBackgroundColor: '#f97316',
        pointBorderColor: '#ffffff',
        pointBorderWidth: 2,
        type: 'line' as const,
        yAxisID: 'y2', // 気温用（中間位置）
        order: 0,
        spanGaps: false // null値の箇所で線を切る
      })
    }
    
    if (weatherDisplayOptions.showHumidity) {
      datasets.push({
        label: '湿度 (%)',
        data: workHoursData.map(d => {
          // 有効な気象データがある場合のみプロット
          return (d.weather_data?.humidity && d.weather_data.humidity > 0) 
            ? d.weather_data.humidity 
            : null
        }),
        borderColor: '#3b82f6', // 青色
        backgroundColor: 'rgba(59, 130, 246, 0.1)',
        fill: false,
        tension: 0.4,
        pointRadius: 6,
        pointHoverRadius: 8,
        pointBackgroundColor: '#3b82f6',
        pointBorderColor: '#ffffff',
        pointBorderWidth: 2,
        type: 'line' as const,
        yAxisID: 'y3', // 湿度用（最も右側）
        order: 0,
        spanGaps: false // null値の箇所で線を切る
      })
    }
    
    // 累積作業時間線（右Y軸用）
    if (showCumulativeWorkTime) {
      let cumulativeHours = 0
      const cumulativeData = workHoursData.map(d => {
        const monthlyTotal = Object.values(d.work_types).reduce((sum, workType) => sum + (workType.total_hours || 0), 0)
        cumulativeHours += monthlyTotal
        // 累積データも単位変換を適用
        return cumulativeHours / cumulativeYAxisRange.unitDivisor
      })

      datasets.push({
        label: '📊 累積作業時間',
        data: cumulativeData,
        borderColor: '#059669', // エメラルド色
        backgroundColor: 'rgba(5, 150, 105, 0.1)',
        borderWidth: 3,
        pointRadius: 5,
        pointBackgroundColor: '#ffffff',
        pointBorderColor: '#059669',
        pointBorderWidth: 2,
        fill: false,
        tension: 0.4,
        type: 'line' as const,
        yAxisID: 'y1', // 累積作業時間用（最も左側）
        order: -1, // 最前面に表示
        pointHoverRadius: 7,
        pointHoverBorderWidth: 3,
      })
    }
    
    const monthLabels = workHoursData.map(d => d.month)
    
    return {
      labels: monthLabels,
      datasets: [...datasets]
    }
  }, [workHoursData, weatherDisplayOptions, showCumulativeWorkTime, yAxisRange, cumulativeYAxisRange])

  // 作業時間割合の計算
  const workTimePercentages = useMemo(() => {
    if (!workHoursData || workHoursData.length === 0) return {}

    const workTypes = Object.keys(WORK_TYPE_COLORS)
    const totalHoursByType: { [key: string]: number } = {}
    let totalAllHours = 0

    // 期間全体の作業時間を集計
    workHoursData.forEach(monthData => {
      Object.entries(monthData.work_types).forEach(([workType, workData]) => {
        const hours = workData?.total_hours || 0
        totalHoursByType[workType] = (totalHoursByType[workType] || 0) + hours
        totalAllHours += hours
      })
    })

    // 割合を計算
    const percentages: { [key: string]: number } = {}
    workTypes.forEach(workType => {
      const hours = totalHoursByType[workType] || 0
      percentages[workType] = totalAllHours > 0 ? Math.round((hours / totalAllHours) * 100) : 0
    })

    return { percentages, totalHours: totalAllHours }
  }, [workHoursData])

  // Y軸範囲の計算
  const yAxisRange = useMemo(() =>
    calculateYAxisRange(workHoursData), [workHoursData, calculateYAxisRange]
  )

  // 累積作業時間用Y軸範囲の計算（大規模データ対応版）
  const cumulativeYAxisRange = useMemo(() => {
    if (!workHoursData || workHoursData.length === 0 || !showCumulativeWorkTime) {
      return {
        min: 0,
        max: 100,
        stepSize: 20,
        tickCount: 6,
        unit: 'hours',
        unitDivisor: 1,
        unitLabel: '時間'
      }
    }

    // 累積データを計算
    let cumulativeHours = 0
    const cumulativeValues = workHoursData.map(d => {
      const monthlyTotal = Object.values(d.work_types).reduce((sum: number, wt: any) =>
        sum + (wt?.total_hours || 0), 0
      )
      cumulativeHours += monthlyTotal
      return cumulativeHours
    })

    const rawMax = Math.max(...cumulativeValues, 10)
    let targetMax = rawMax * 1.2

    // 単位の自動選択（左軸と同じロジック）
    let unit = 'hours'
    let unitDivisor = 1
    let unitLabel = '時間'

    if (targetMax >= 50000) {
      unit = 'man'
      unitDivisor = 10000
      unitLabel = '万時間'
      targetMax = targetMax / 10000
    } else if (targetMax >= 5000) {
      unit = 'sen'
      unitDivisor = 1000
      unitLabel = '千時間'
      targetMax = targetMax / 1000
    }

    // 左軸と必ず同じメモリ数にする
    const targetTickCount = yAxisRange.tickCount || 6

    // 単位変換後の最適なステップサイズ
    const niceSteps = [
      0.1, 0.2, 0.25, 0.5,
      1, 2, 2.5, 5,
      10, 20, 25, 50,
      100, 200, 250, 500,
      1000, 2000, 2500, 5000,
      10000
    ]

    let bestStep = 1
    for (const step of niceSteps) {
      const candidateMax = step * (targetTickCount - 1)
      if (candidateMax >= targetMax) {
        bestStep = step
        break
      }
    }

    // フォールバック処理
    if (bestStep * (targetTickCount - 1) < targetMax) {
      bestStep = Math.ceil(targetMax / (targetTickCount - 1))
    }

    const adjustedMax = bestStep * (targetTickCount - 1)

    return {
      min: 0,
      max: adjustedMax,
      stepSize: bestStep,
      tickCount: targetTickCount,
      unit,
      unitDivisor,
      unitLabel
    }
  }, [workHoursData, yAxisRange, showCumulativeWorkTime])

  // チャートエリア寸法の更新
  const updateChartDimensions = useCallback(() => {
    if (chartRef.current) {
      const chart = chartRef.current
      const chartArea = chart.chartArea
      const meta = chart.getDatasetMeta(0)
      
      if (chartArea && meta && meta.data.length > 0) {
        const firstBar = meta.data[0]
        const lastBar = meta.data[meta.data.length - 1]
        
        if (firstBar && lastBar) {
          const actualLeft = firstBar.x - (firstBar.width || 0) / 2
          const actualRight = lastBar.x + (lastBar.width || 0) / 2
          const actualWidth = actualRight - actualLeft
          
          setChartDimensions({
            left: Math.round(actualLeft),
            right: Math.round(chart.width - actualRight),
            width: Math.round(actualWidth)
          })
        }
      }
    }
  }, [])

  useEffect(() => {
    if (chartRef.current && workHoursData.length > 0) {
      setTimeout(updateChartDimensions, 100)
    }
  }, [workHoursData, updateChartDimensions])

  // 複数右軸表示用のカスタムプラグイン（無効化 - 軸位置は afterFit で制御）
  const multipleRightAxisPlugin = {
    id: 'multipleRightAxis',
    beforeDraw: (chart: any) => {
      // 軸の動的な位置調整は行わない
      // 全ての軸位置は afterFit 関数で固定的に制御される
    }
  }

  // チャートオプション
  const chartOptions: ChartOptions<'bar'> = useMemo(() => {
    // 表示されているY軸の数を計算
    const visibleAxesCount =
      (showCumulativeWorkTime ? 1 : 0) +
      (weatherDisplayOptions.showTemperature ? 1 : 0) +
      (weatherDisplayOptions.showHumidity ? 1 : 0);

    // Y軸の数に応じて右側パディングを動的に調整
    const rightPadding = visibleAxesCount === 0 ? 0 :
                        visibleAxesCount === 1 ? 0 :
                        visibleAxesCount === 2 ? 10 :
                        20; // 3軸の場合

    return ({
    responsive: true,
    maintainAspectRatio: false,
    layout: {
      padding: {
        left: 0,
        // Y軸の数に応じて動的に調整
        right: rightPadding,
        top: 0,
        bottom: 0
      },
      autoPadding: false // 自動パディング調整を無効化
    },
    interaction: {
      mode: 'index',
      intersect: false
    },
    onClick: (event: ChartEvent, elements: InteractionItem[]) => {
      if (elements.length > 0 && chartRef.current) {
        const elementIndex = elements[0].index
        const selectedData = workHoursData[elementIndex]
        if (selectedData) {
          setSelectedMonth(selectedData)
          setDrilldownOpen(true)
        }
      }
    },
    scales: {
      x: {
        type: 'category',
        stacked: true,
        grid: {
          display: false,
          drawBorder: true,
          drawOnChartArea: false,
          drawTicks: false
        },
        ticks: {
          display: false,
          maxRotation: 0,
          minRotation: 0
        },
        border: {
          display: true,
          color: '#e5e7eb',
          width: 1
        },
        offset: true,
        barPercentage: responsiveDimensions.barPercentage,
        categoryPercentage: responsiveDimensions.categoryPercentage,
        bounds: 'ticks',
        afterFit: function(scale: any) {
          scale.paddingBottom = 60
          // 左右のパディングは固定（動的調整しない）
          scale.paddingLeft = 0
          scale.paddingRight = 0
        }
      },
      y: {
        type: 'linear',
        display: true,
        position: 'left',
        stacked: true,
        min: yAxisRange.min,
        max: yAxisRange.max,
        grid: {
          color: '#e5e7eb',
          lineWidth: 1,
          drawTicks: false
        },
        border: {
          color: '#374151',
          width: 2 // 固定幅
        },
        ticks: {
          stepSize: yAxisRange.stepSize, // 11個の目盛りに固定
          color: '#1f2937',
          font: {
            size: Math.max(12, responsiveDimensions.fontSize + 1), // 固定サイズ
            weight: '600',
            family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
          },
          padding: 8, // 固定パディング
          callback: function(value) {
            const numValue = value as number
            // 1000以上は千h表記、未満は通常表記
            if (numValue >= 1000) {
              return `${(numValue / 1000).toFixed(1)}千h`
            }
            return `${numValue.toFixed(1)}h`
          }
        },
        // 左側Y軸は常に固定位置
        beginAtZero: false,
        offset: false // オフセットを無効化
      },
      // 📊 累積作業時間軸（最も左側）
      ...(showCumulativeWorkTime ? {
        y1: {
          type: 'linear' as const,
          display: true,
          position: 'right' as const,
          min: cumulativeYAxisRange.min,
          max: cumulativeYAxisRange.max,
          grid: {
            drawOnChartArea: false,
          },
          border: {
            color: '#059669', // エメラルド色
            width: 2
          },
          ticks: {
            stepSize: cumulativeYAxisRange.stepSize,
            color: '#059669',
            font: {
              size: Math.max(12, responsiveDimensions.fontSize + 1),
              weight: '600' as const,
              family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
            },
            padding: 1,
            callback: function(value: any) {
              const numValue = value as number
              // 1000以上は千h表記、未満は通常表記
              if (numValue >= 1000) {
                return `${(numValue / 1000).toFixed(1)}千h`
              }
              return `${numValue}h`
            }
          },
          title: {
            display: true,
            text: `累積作業時間 (${cumulativeYAxisRange.unitLabel})`,
            color: '#059669',
            font: {
              size: 13,
              weight: 'bold' as const
            },
            padding: 4
          },
          // 累積作業時間軸は最も左側（グラフに接して配置）
          offset: false
        }
      } : {}),
      // 🌡️ 気温軸（中間位置）
      ...(weatherDisplayOptions.showTemperature ? {
        y2: {
          type: 'linear' as const,
          display: true,
          position: 'right' as const,
          min: -10,  // 実用的な範囲に調整
          max: 40,   // 日本の気候に適した範囲
          grid: {
            drawOnChartArea: false,
          },
          border: {
            color: '#f97316',
            width: 2
          },
          ticks: {
            stepSize: 10,  // 10度刻みで6個の目盛り（-10, 0, 10, 20, 30, 40）
            color: '#f97316',
            font: {
              size: Math.max(12, responsiveDimensions.fontSize + 1),
              weight: '600' as const,
              family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
            },
            padding: 1,
            callback: function(value: any) {
              return `${value}°C`
            }
          },
          title: {
            display: false
          },
          // 気温軸は中間位置に配置
          offset: true
        }
      } : {}),
      // 💧 湿度軸（最も右側）
      ...(weatherDisplayOptions.showHumidity ? {
        y3: {
          type: 'linear' as const,
          display: true,
          position: 'right' as const,
          min: 0,   // 0%から
          max: 100,  // 100%まで
          grid: {
            drawOnChartArea: false,
          },
          border: {
            color: '#3b82f6',
            width: 2
          },
          ticks: {
            stepSize: 20,  // 20%刻みで6個の目盛り（0, 20, 40, 60, 80, 100）
            color: '#3b82f6',
            font: {
              size: Math.max(12, responsiveDimensions.fontSize + 1),
              weight: '600' as const,
              family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
            },
            padding: 1,
            callback: function(value: any) {
              return `${value}%`
            }
          },
          title: {
            display: false
          },
          // 湿度軸は最も右側に配置
          offset: true
        }
      } : {})
    },
    plugins: {
      legend: {
        display: false
      },
      multipleRightAxis: true,
      tooltip: {
        backgroundColor: '#ffffff',
        titleColor: '#1f2937',
        bodyColor: '#374151',
        borderColor: '#d1d5db',
        borderWidth: 1,
        cornerRadius: 8,
        padding: 12,
        displayColors: true, // 色付きマーカーを表示
        titleFont: {
          size: 14,
          weight: '600'
        },
        bodyFont: {
          size: 12,
          weight: '400'
        },
        interaction: {
          mode: 'point' as const, // ポイントごとに個別表示
          intersect: false // カーソルが近くにあれば表示
        },
        callbacks: {
          title: (context) => {
            const dataIndex = context[0].dataIndex
            const data = workHoursData[dataIndex]
            return `${data.year}年${data.month} - 作業時間分析`
          },
          label: (context) => {
            const value = context.raw as number
            const datasetLabel = context.dataset.label || ''
            const datasetType = context.dataset.type || 'bar'
            
            // 線グラフ（累積データ）の場合
            if (datasetType === 'line') {
              if (datasetLabel.includes('累積')) {
                return `${datasetLabel}: ${value.toLocaleString()}時間`
              } else if (datasetLabel.includes('気温')) {
                return `${datasetLabel}: ${value}°C`
              } else if (datasetLabel.includes('湿度')) {
                return `${datasetLabel}: ${value}%`
              }
            }
            
            // 棒グラフ（作業種別データ）の場合
            const workType = datasetLabel.replace('作業', '')
            if (value > 0) {
              return `${datasetLabel}: ${value.toLocaleString()}時間`
            } else if (value === 0) {
              return `${datasetLabel}: 実施なし`
            }
            return `${datasetLabel}: ${value.toLocaleString()}時間`
          },
          afterBody: (context) => {
            const dataIndex = context[0].dataIndex
            const data = workHoursData[dataIndex]
            const result = []
            
            // 月次サマリー
            result.push('', '📊 【月次サマリー】')
            result.push(`💪 総作業時間: ${data.monthly_total_hours.toLocaleString()}時間`)
            result.push(`💰 総収益: ¥${data.monthly_total_revenue.toLocaleString()}`)
            result.push(`💸 総コスト: ¥${data.monthly_total_cost.toLocaleString()}`)
            result.push(`📈 平均効率: ${(data.monthly_avg_efficiency * 100).toFixed(1)}%`)
            
            // 作業種別の詳細（上位3件）
            const workTypesArray = Object.entries(data.work_types)
              .filter(([_, details]) => details.total_hours > 0)
              .sort((a, b) => b[1].total_hours - a[1].total_hours)
              .slice(0, 3)
            
            if (workTypesArray.length > 0) {
              result.push('', '🔍 【作業種別TOP3】')
              workTypesArray.forEach(([type, details]) => {
                const workTypeLabel = WORK_TYPE_LABELS[type as keyof typeof WORK_TYPE_LABELS] || type
                result.push(`• ${workTypeLabel}: ${details.total_hours}h (${details.work_count}回)`)
                if (details.roi_per_hour > 0) {
                  result.push(`  ROI: ¥${Math.round(details.roi_per_hour)}/h`)
                }
              })
            }
            
            // AI予測情報
            if (data.ai_predictions) {
              result.push('', '🤖 【AI予測分析】')
              result.push(`予測作業時間: ${data.ai_predictions.predicted_hours}時間`)
              
              const trendEmoji = data.ai_predictions.efficiency_trend === 'improving' ? '📈' :
                                data.ai_predictions.efficiency_trend === 'declining' ? '📉' : '➡️'
              const trendText = data.ai_predictions.efficiency_trend === 'improving' ? '改善傾向' :
                               data.ai_predictions.efficiency_trend === 'declining' ? '低下傾向' : '横ばい'
              result.push(`効率トレンド: ${trendEmoji} ${trendText}`)
              result.push(`最適化スコア: ${(data.ai_predictions.optimization_score * 100).toFixed(0)}%`)
              
              // AI提案（最初の1つのみ表示）
              if (data.ai_predictions.suggestions && data.ai_predictions.suggestions.length > 0) {
                result.push(`💡 ${data.ai_predictions.suggestions[0]}`)
              }
            }
            
            // 業界ベンチマーク
            if (data.benchmarks) {
              result.push('', '📊 【業界ベンチマーク】')
              result.push(`業界平均: ${data.benchmarks.industry_average_hours}時間`)
              result.push(`トップ企業: ${data.benchmarks.top_performers_hours}時間`)
              result.push(`効率順位: 上位${data.benchmarks.efficiency_percentile}%`)
            }
            
            // 気象情報
            if (data.weather_data && (weatherDisplayOptions.showTemperature || weatherDisplayOptions.showHumidity)) {
              result.push('', '🌡️💧 【気象条件】')
              if (weatherDisplayOptions.showTemperature) {
                result.push(`平均気温: ${data.weather_data.temperature}°C`)
                result.push(`気温範囲: ${data.weather_data.temperature_range.min}°C～${data.weather_data.temperature_range.max}°C`)
              }
              if (weatherDisplayOptions.showHumidity) {
                result.push(`平均湿度: ${data.weather_data.humidity}%`)
                result.push(`湿度範囲: ${data.weather_data.humidity_range.min}%～${data.weather_data.humidity_range.max}%`)
              }
            }
            
            // 累積作業時間が表示されている場合
            const hoveredDataset = context[0].dataset
            if (hoveredDataset && hoveredDataset.type === 'line' && hoveredDataset.label?.includes('累積')) {
              result.push('', '📈 【累積分析】')
              const cumulativeHours = hoveredDataset.data[dataIndex] as number
              result.push(`累積作業時間: ${cumulativeHours.toLocaleString()}時間`)
              
              // 前月比較
              if (dataIndex > 0) {
                const prevCumulative = hoveredDataset.data[dataIndex - 1] as number
                const monthlyIncrease = cumulativeHours - prevCumulative
                const growthRate = prevCumulative > 0 ? ((monthlyIncrease / prevCumulative) * 100).toFixed(1) : '0.0'
                result.push(`前月比: +${monthlyIncrease.toLocaleString()}時間 (${growthRate}%増)`)
              }
            }
            
            result.push('', '💡 クリックで詳細分析を表示')
            
            return result
          }
        }
      }
    },
    animation: {
      duration: 600,
      easing: 'easeOutQuart',
      onComplete: function(animation) {
        setTimeout(updateChartDimensions, 50)
      }
    },
    onResize: function(chart, size) {
      setTimeout(updateChartDimensions, 50)
    }
  })}, [yAxisRange, workHoursData, updateChartDimensions, responsiveDimensions, weatherDisplayOptions, showCumulativeWorkTime])

  // 年月選択ハンドラー
  const handleYearMonthChange = () => {
    const newDate = new Date(selectedYear, selectedMonthNum - 1, 1)
    setStartMonth(newDate)
    setYearMonthPickerOpen(false)
  }

  // 年月選択の初期化
  React.useEffect(() => {
    setSelectedYear(startMonth.getFullYear())
    setSelectedMonthNum(startMonth.getMonth() + 1)
  }, [startMonth])

  // 合計値の計算
  const periodTotals = useMemo(() => {
    if (!workHoursData || workHoursData.length === 0) return {}
    
    const totals: { [workType: string]: number } = {}
    Object.keys(WORK_TYPE_COLORS).forEach(workType => {
      totals[workType] = workHoursData.reduce((sum, d) => 
        sum + (d.work_types[workType]?.total_hours || 0), 0
      )
    })
    return totals
  }, [workHoursData])

  if (loading) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>AI予測作業時間分析</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-[600px] flex items-center justify-center">
            <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-indigo-500"></div>
          </div>
        </CardContent>
      </Card>
    )
  }

  return (
    <>
      <Card>
        <CardHeader className="bg-gradient-to-r from-green-600 to-emerald-600 text-white">
          <div className="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-4">
            <div className="flex items-center gap-3">
              <div className="w-12 h-12 bg-white/20 rounded-lg flex items-center justify-center backdrop-blur-sm">
                <Clock className="w-6 h-6" />
              </div>
              <div>
                <CardTitle className="text-xl font-bold">
                  🤖 AI予測作業時間分析
                </CardTitle>
                <p className="text-green-100 text-sm">
                  AI-Powered Work Hours & ROI Analysis
                </p>
              </div>
            </div>
            <div className="text-right">
              <div className="text-xs text-green-100 uppercase tracking-wider">AgriFinance Pro</div>
              <div className="text-sm font-medium">労働効率最適化システム</div>
            </div>
          </div>
        </CardHeader>
        
        <CardContent className="p-6">
          {/* フィルターコントロール */}
          <div className="mb-6 p-4 bg-gradient-to-r from-gray-50 to-indigo-50 rounded-lg border">
            <div className="flex flex-col sm:flex-row gap-4 items-start sm:items-center justify-between">
              <div className="flex items-center gap-3 flex-wrap">
                {/* 表示期間選択 */}
                <div className="flex items-center gap-1 bg-white rounded-lg p-1 shadow-sm">
                  {[1, 2, 3].map((period) => (
                    <Button
                      key={period}
                      variant={displayPeriod === period ? 'default' : 'ghost'}
                      size="sm"
                      onClick={() => setDisplayPeriod(period as 1 | 2 | 3)}
                      className={`px-3 h-7 text-xs ${
                        displayPeriod === period 
                          ? 'bg-indigo-600 text-white shadow-sm' 
                          : 'text-gray-600 hover:bg-gray-50 hover:text-gray-800'
                      }`}
                    >
                      {period}年
                    </Button>
                  ))}
                </div>
                
                {/* AI洞察トグル */}
                <Button
                  variant={showAIInsights ? 'default' : 'outline'}
                  size="sm"
                  onClick={() => setShowAIInsights(!showAIInsights)}
                  className={showAIInsights ? 'bg-purple-600 hover:bg-purple-700 text-white' : 'text-gray-600'}
                >
                  <Zap className="w-4 h-4 mr-1" />
                  AI洞察
                </Button>

                {/* 累積作業時間線トグル */}
                <Button
                  variant={showCumulativeWorkTime ? 'default' : 'outline'}
                  size="sm"
                  onClick={() => setShowCumulativeWorkTime(!showCumulativeWorkTime)}
                  className={showCumulativeWorkTime ? 'bg-emerald-600 hover:bg-emerald-700 text-white' : 'text-gray-600'}
                >
                  📊 累積時間線
                </Button>
                
                {/* 前年比較トグル */}
                <Button
                  variant={showComparison ? 'default' : 'outline'}
                  size="sm"
                  onClick={() => setShowComparison(!showComparison)}
                  disabled={previousYearData.length === 0}
                  className={showComparison ? 'bg-blue-600 hover:bg-blue-700 text-white' : 'text-gray-600'}
                >
                  📈 前年比較
                </Button>
                
                {/* 🌡️💧 気象データ表示トグル */}
                <div className="flex items-center gap-2 bg-white rounded-lg p-1 shadow-sm">
                  <Button
                    variant={weatherDisplayOptions.showTemperature ? 'default' : 'ghost'}
                    size="sm"
                    onClick={() => setWeatherDisplayOptions(prev => ({
                      ...prev,
                      showTemperature: !prev.showTemperature
                    }))}
                    className={`px-3 h-7 text-xs ${
                      weatherDisplayOptions.showTemperature 
                        ? 'bg-orange-500 text-white shadow-sm' 
                        : 'text-orange-600 hover:bg-orange-50'
                    }`}
                  >
                    🌡️ 気温
                  </Button>
                  <Button
                    variant={weatherDisplayOptions.showHumidity ? 'default' : 'ghost'}
                    size="sm"
                    onClick={() => setWeatherDisplayOptions(prev => ({
                      ...prev,
                      showHumidity: !prev.showHumidity
                    }))}
                    className={`px-3 h-7 text-xs ${
                      weatherDisplayOptions.showHumidity 
                        ? 'bg-blue-500 text-white shadow-sm' 
                        : 'text-blue-600 hover:bg-blue-50'
                    }`}
                  >
                    💧 湿度
                  </Button>
                </div>
                
                {/* 年月選択 - 金融×農業デザイン */}
                <Popover open={yearMonthPickerOpen} onOpenChange={setYearMonthPickerOpen} modal={true}>
                  <PopoverTrigger asChild>
                    <Button
                      variant="outline"
                      size="sm"
                      className="flex items-center gap-2 min-w-[160px] bg-gradient-to-r from-emerald-50 to-green-50 border-emerald-200 hover:from-emerald-100 hover:to-green-100 transition-all duration-200 shadow-sm"
                    >
                      <div className="flex items-center gap-2">
                        <div className="w-6 h-6 bg-emerald-500 rounded-full flex items-center justify-center">
                          <CalendarIcon className="w-3 h-3 text-white" />
                        </div>
                        <div className="flex flex-col items-start">
                          <span className="font-bold text-emerald-800">{format(startMonth, 'yyyy年', { locale: ja })}</span>
                          <span className="text-xs text-emerald-600">{format(startMonth, 'M月開始', { locale: ja })}</span>
                        </div>
                        <Sprout className="w-4 h-4 text-emerald-500 ml-auto" />
                      </div>
                    </Button>
                  </PopoverTrigger>
                  <PopoverContent className="w-96 p-0 bg-white border-2 border-emerald-200 shadow-2xl z-50 rounded-xl overflow-hidden">
                    <div className="p-5 border-b border-emerald-100 bg-gradient-to-r from-emerald-600 to-green-600 text-white">
                      <h4 className="font-bold text-lg flex items-center gap-2">
                        <Sprout className="w-5 h-5" />
                        栽培期間設定
                      </h4>
                      <p className="text-sm text-emerald-100 mt-1">分析開始年月を選択（{displayPeriod}年間分析）</p>
                    </div>
                    
                    <div className="p-4 space-y-4">
                      {/* 年選択 */}
                      <div className="space-y-2">
                        <label className="text-sm font-medium text-gray-700 flex items-center gap-2">
                          📅 年
                          <span className="text-xs text-gray-500">（過去30年から選択）</span>
                        </label>
                        <div className="h-32 overflow-y-auto border border-gray-200 rounded-lg bg-gray-50 p-2">
                          <div className="grid grid-cols-3 gap-2">
                            {Array.from({length: 30}, (_, i) => new Date().getFullYear() - i).map(year => (
                              <Button
                                key={year}
                                variant={selectedYear === year ? 'default' : 'outline'}
                                size="sm"
                                onClick={() => setSelectedYear(year)}
                                className={`text-xs h-8 ${
                                  selectedYear === year 
                                    ? 'bg-indigo-600 text-white shadow-md scale-105' 
                                    : 'hover:bg-indigo-50 bg-white'
                                } transition-all duration-200`}
                              >
                                {year}
                              </Button>
                            ))}
                          </div>
                        </div>
                      </div>
                      
                      {/* 月選択 */}
                      <div className="space-y-2">
                        <label className="text-sm font-medium text-gray-700">月</label>
                        <div className="grid grid-cols-4 gap-2">
                          {Array.from({length: 12}, (_, i) => i + 1).map(month => (
                            <Button
                              key={month}
                              variant={selectedMonthNum === month ? 'default' : 'outline'}
                              size="sm"
                              onClick={() => setSelectedMonthNum(month)}
                              className={`text-xs ${selectedMonthNum === month ? 'bg-indigo-600 text-white' : 'hover:bg-indigo-50'}`}
                            >
                              {month}月
                            </Button>
                          ))}
                        </div>
                      </div>
                      
                      {/* アクションボタン */}
                      <div className="flex gap-2 pt-2">
                        <Button
                          onClick={handleYearMonthChange}
                          className="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white"
                          size="sm"
                        >
                          ✅ 期間を適用
                        </Button>
                        <Button
                          onClick={() => setYearMonthPickerOpen(false)}
                          variant="outline"
                          size="sm"
                          className="px-4"
                        >
                          キャンセル
                        </Button>
                      </div>
                    </div>
                  </PopoverContent>
                </Popover>
              </div>
              
              <div className="text-xs text-gray-500">
                最終更新: {lastUpdated.toLocaleString('ja-JP', { 
                  month: 'short', 
                  day: 'numeric', 
                  hour: '2-digit', 
                  minute: '2-digit' 
                })}
              </div>
            </div>
          </div>
          
          {/* グラフ */}
          <div ref={containerRef} className="h-[600px] relative overflow-visible">
            {chartData && (
              <div className="relative z-10" style={{ height: '580px' }}>
                <Bar 
                  ref={chartRef}
                  data={chartData} 
                  options={{
                    ...chartOptions,
                    maintainAspectRatio: false,
                    aspectRatio: undefined
                  }}
                  plugins={[multipleRightAxisPlugin]}
                />
              </div>
            )}
            
            {/* カスタムX軸ラベル */}
            {chartDimensions.width > 0 && (
              <div 
                className="absolute bottom-0 pointer-events-none z-0" 
                style={{ 
                  left: `${chartDimensions.left}px`,
                  right: `${chartDimensions.right}px`,
                  width: `${chartDimensions.width}px`
                }}
              >
                {/* 月表示層 */}
                <div className="relative bg-white border-t border-gray-300" style={{ height: '40px' }}>
                  {workHoursData.map((data, index) => {
                    const chart = chartRef.current
                    let barLeftX = chartDimensions.width / workHoursData.length * index
                    let barWidth = chartDimensions.width / workHoursData.length
                    
                    if (chart) {
                      const meta = chart.getDatasetMeta(0)
                      if (meta && meta.data[index]) {
                        const bar = meta.data[index]
                        barLeftX = (bar.x - (bar.width || 0) / 2) - chartDimensions.left
                        barWidth = bar.width || barWidth
                      }
                    }
                    
                    return (
                      <div
                        key={`month-${index}`}
                        className="absolute text-center text-sm font-medium text-gray-800 py-2 flex items-center justify-center"
                        style={{ 
                          left: `${barLeftX}px`,
                          width: `${barWidth}px`,
                          top: '0px',
                          height: '40px'
                        }}
                      >
                        {data.month}
                      </div>
                    )
                  })}
                </div>
                
                {/* 年表示層 */}
                <div className="relative border-t-2 border-gray-400 bg-gray-100" style={{ height: '40px' }}>
                  {(() => {
                    const yearGroups = []
                    let currentYear = null
                    let yearStartIndex = 0
                    
                    workHoursData.forEach((data, index) => {
                      if (data.year !== currentYear) {
                        if (currentYear !== null) {
                          yearGroups.push({ 
                            year: currentYear, 
                            startIndex: yearStartIndex, 
                            endIndex: index - 1 
                          })
                        }
                        currentYear = data.year
                        yearStartIndex = index
                      }
                    })
                    
                    if (currentYear !== null) {
                      yearGroups.push({ 
                        year: currentYear, 
                        startIndex: yearStartIndex, 
                        endIndex: workHoursData.length - 1 
                      })
                    }
                    
                    return yearGroups.map((yearData) => {
                      const chart = chartRef.current
                      let startX = 0
                      let endX = chartDimensions.width
                      
                      if (chart) {
                        const meta = chart.getDatasetMeta(0)
                        if (meta && meta.data.length > 0) {
                          const startBar = meta.data[yearData.startIndex]
                          const endBar = meta.data[yearData.endIndex]
                          
                          if (startBar && endBar) {
                            startX = (startBar.x - (startBar.width || 0) / 2) - chartDimensions.left
                            endX = (endBar.x + (endBar.width || 0) / 2) - chartDimensions.left
                          }
                        }
                      }
                      
                      const yearWidth = endX - startX
                      
                      return (
                        <div
                          key={`year-${yearData.year}`}
                          className="absolute text-center text-sm font-bold text-gray-900 py-2 bg-gray-50 flex items-center justify-center border-r border-gray-400"
                          style={{ 
                            left: `${startX}px`,
                            width: `${yearWidth}px`,
                            top: '0px',
                            height: '40px'
                          }}
                        >
                          {yearData.year}年
                        </div>
                      )
                    })
                  })()}
                </div>
              </div>
            )}
          </div>
          
          {/* 作業種別凡例（折りたたみ可能） */}
          <Collapsible open={isWorkTypeTotalsOpen} onOpenChange={setIsWorkTypeTotalsOpen}>
            <div className="mt-6 p-4 bg-gradient-to-r from-gray-50 to-indigo-50 border border-gray-200 rounded-lg">
              <CollapsibleTrigger className="w-full">
                <h4 className="font-medium text-gray-800 mb-3 flex items-center gap-2 cursor-pointer hover:text-gray-600">
                  <ChevronRight
                    className={`w-4 h-4 transition-transform duration-200 ${isWorkTypeTotalsOpen ? 'rotate-90' : ''}`}
                  />
                  ⏰ 作業種別・期間合計時間
                  <span className="text-xs text-gray-500 font-normal">
                    （合計: {workTimePercentages.totalHours?.toFixed(1) || 0}時間）
                  </span>
                  <span className="text-xs text-gray-500 ml-auto">
                    {isWorkTypeTotalsOpen ? '閉じる' : '展開する'}
                  </span>
                </h4>
              </CollapsibleTrigger>
              <CollapsibleContent>
                <div className="grid grid-cols-2 md:grid-cols-4 gap-3">
                  {Object.entries(WORK_TYPE_LABELS).map(([workType, label]) => (
                    <div key={workType} className="flex items-center gap-2 p-2 bg-white rounded border shadow-sm">
                      <div
                        className="w-4 h-4 rounded flex-shrink-0"
                        style={{ backgroundColor: WORK_TYPE_COLORS[workType as keyof typeof WORK_TYPE_COLORS] }}
                      />
                      <div className="flex-1 min-w-0">
                        <div className="text-sm font-medium text-gray-700 truncate">{label}</div>
                        <div className="text-xs text-gray-500 space-y-1">
                          <div>{(periodTotals[workType] || 0).toFixed(1)}時間</div>
                          <div className="font-semibold text-indigo-600">
                            {workTimePercentages.percentages?.[workType] || 0}%
                          </div>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </CollapsibleContent>
            </div>
          </Collapsible>
          
          {/* AI洞察パネル */}
          {showAIInsights && workHoursData.length > 0 && (
            <div className="mt-4 p-4 bg-gradient-to-r from-purple-50 to-indigo-50 border border-purple-200 rounded-lg">
              <h4 className="font-medium text-purple-800 mb-3 flex items-center gap-2">
                <Zap className="w-4 h-4" />
                🤖 AI分析洞察
              </h4>
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 text-sm">
                {workHoursData[workHoursData.length - 1]?.ai_predictions && (
                  <>
                    <div className="bg-white border border-purple-200 rounded-lg p-3">
                      <div className="font-semibold text-purple-800 mb-1">効率性トレンド</div>
                      <div className={`text-lg font-bold mb-2 ${
                        workHoursData[workHoursData.length - 1].ai_predictions!.efficiency_trend === 'improving' ? 'text-green-600' :
                        workHoursData[workHoursData.length - 1].ai_predictions!.efficiency_trend === 'declining' ? 'text-red-600' :
                        'text-blue-600'
                      }`}>
                        {workHoursData[workHoursData.length - 1].ai_predictions!.efficiency_trend === 'improving' ? '📈 改善中' :
                         workHoursData[workHoursData.length - 1].ai_predictions!.efficiency_trend === 'declining' ? '📉 低下中' :
                         '➡️ 安定'}
                      </div>
                      <div className="text-xs text-gray-600">
                        最適化スコア: {workHoursData[workHoursData.length - 1].ai_predictions!.optimization_score}%
                      </div>
                    </div>
                    
                    <div className="bg-white border border-purple-200 rounded-lg p-3">
                      <div className="font-semibold text-purple-800 mb-1">来月予測</div>
                      <div className="text-lg font-bold text-blue-600 mb-2">
                        {workHoursData[workHoursData.length - 1].ai_predictions!.predicted_hours.toFixed(0)}時間
                      </div>
                      <div className="text-xs text-gray-600">
                        前月比: {((workHoursData[workHoursData.length - 1].ai_predictions!.predicted_hours / workHoursData[workHoursData.length - 1].monthly_total_hours - 1) * 100).toFixed(1)}%
                      </div>
                    </div>
                    
                    {workHoursData[workHoursData.length - 1]?.benchmarks && (
                      <div className="bg-white border border-purple-200 rounded-lg p-3">
                        <div className="font-semibold text-purple-800 mb-1">業界比較</div>
                        <div className="text-lg font-bold text-indigo-600 mb-2">
                          {workHoursData[workHoursData.length - 1].benchmarks!.efficiency_percentile}%ile
                        </div>
                        <div className="text-xs text-gray-600">
                          {workHoursData[workHoursData.length - 1].benchmarks!.efficiency_percentile >= 75 ? '上位四分位' :
                           workHoursData[workHoursData.length - 1].benchmarks!.efficiency_percentile >= 50 ? '平均以上' :
                           '改善余地あり'}
                        </div>
                      </div>
                    )}
                  </>
                )}
              </div>
              
              {/* AI提案 */}
              {workHoursData[workHoursData.length - 1]?.ai_predictions?.suggestions && workHoursData[workHoursData.length - 1].ai_predictions!.suggestions.length > 0 && (
                <div className="mt-4 p-3 bg-white border border-purple-200 rounded-lg">
                  <div className="font-semibold text-purple-800 mb-2 flex items-center gap-2">
                    <Target className="w-4 h-4" />
                    AI最適化提案
                  </div>
                  <ul className="text-sm text-gray-700 space-y-1">
                    {workHoursData[workHoursData.length - 1].ai_predictions!.suggestions.map((suggestion, index) => (
                      <li key={index} className="flex items-start gap-2">
                        <span className="text-purple-500 mt-1">•</span>
                        {suggestion}
                      </li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          )}
          
          <div className="mt-4 text-xs text-gray-500 text-center">
            💡 各月の棒グラフをクリックすると詳細分析を表示できます
            {showAIInsights && <span className="ml-2">｜🤖 AI予測モード有効</span>}
          </div>
        </CardContent>
      </Card>

      {/* 詳細分析ダイアログ */}
      <Dialog open={drilldownOpen} onOpenChange={setDrilldownOpen} modal={true}>
        <LargeDialogContent 
          width="1200px" 
          height="900px"
          title={selectedMonth ? `${selectedMonth.year}年${selectedMonth.month}の作業時間詳細分析` : "作業時間詳細分析"}
        >
          {/* ヘッダー */}
          <div className="bg-gradient-to-r from-indigo-600 via-purple-600 to-pink-600 -mx-6 -mt-6 mb-6 px-6 py-4 rounded-t-lg">
            <div className="flex items-center justify-between text-white">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 bg-white/20 rounded-lg flex items-center justify-center backdrop-blur-sm">
                  <Clock className="w-5 h-5" />
                </div>
                <div>
                  <h2 className="text-xl font-bold tracking-tight">
                    {selectedMonth && `${selectedMonth.year}年${selectedMonth.month}`}
                  </h2>
                  <p className="text-indigo-100 text-sm">AI予測作業時間詳細分析レポート</p>
                </div>
              </div>
              <div className="text-right">
                <div className="text-xs text-indigo-100 uppercase tracking-wider">AgriTech Pro</div>
                <div className="text-lg font-semibold">労働効率最適化システム</div>
              </div>
            </div>
          </div>
          
          {selectedMonth && (
            <div className="space-y-6">
              {/* エグゼクティブサマリー */}
              <div className="bg-gradient-to-r from-gray-50 to-indigo-50 border border-gray-200 rounded-lg p-5">
                <h3 className="text-lg font-bold text-gray-800 mb-4 flex items-center gap-2">
                  ⚡ 作業効率サマリー
                  <div className="ml-auto px-2 py-1 bg-indigo-100 text-indigo-700 text-xs font-medium rounded-full">
                    労働生産性指標
                  </div>
                </h3>
                <div className="grid grid-cols-4 gap-4">
                  {/* 総作業時間 */}
                  <div className="bg-white border border-indigo-200 rounded-lg p-4 shadow-sm">
                    <div className="flex items-center justify-between mb-2">
                      <div className="w-10 h-10 bg-indigo-100 rounded-full flex items-center justify-center">
                        <Clock className="w-5 h-5 text-indigo-600" />
                      </div>
                      <div className="text-xs text-indigo-600 font-medium px-2 py-1 bg-indigo-50 rounded">
                        作業時間
                      </div>
                    </div>
                    <div className="text-2xl font-bold text-indigo-700 mb-1">
                      {selectedMonth.monthly_total_hours.toFixed(1)}h
                    </div>
                    <div className="text-sm text-gray-600">総作業時間 | Total Hours</div>
                    <div className="text-xs text-gray-500 mt-1">全作業の合計時間</div>
                  </div>
                  
                  {/* 平均効率 */}
                  <div className="bg-white border border-green-200 rounded-lg p-4 shadow-sm">
                    <div className="flex items-center justify-between mb-2">
                      <div className="w-10 h-10 bg-green-100 rounded-full flex items-center justify-center">
                        <Target className="w-5 h-5 text-green-600" />
                      </div>
                      <div className="text-xs text-green-600 font-medium px-2 py-1 bg-green-50 rounded">
                        効率性
                      </div>
                    </div>
                    <div className="text-2xl font-bold text-green-700 mb-1">
                      {selectedMonth.monthly_avg_efficiency.toFixed(1)}
                    </div>
                    <div className="text-sm text-gray-600">平均効率スコア | Efficiency</div>
                    <div className="text-xs text-gray-500 mt-1">100点満点の効率指標</div>
                  </div>
                  
                  {/* 時間あたり収益 */}
                  <div className="bg-white border border-purple-200 rounded-lg p-4 shadow-sm">
                    <div className="flex items-center justify-between mb-2">
                      <div className="w-10 h-10 bg-purple-100 rounded-full flex items-center justify-center">
                        <TrendingUp className="w-5 h-5 text-purple-600" />
                      </div>
                      <div className="text-xs text-purple-600 font-medium px-2 py-1 bg-purple-50 rounded">
                        時給効率
                      </div>
                    </div>
                    <div className="text-2xl font-bold text-purple-700 mb-1">
                      ¥{selectedMonth.monthly_total_hours > 0 ? 
                        Math.round(selectedMonth.monthly_total_revenue / selectedMonth.monthly_total_hours) : 0}
                    </div>
                    <div className="text-sm text-gray-600">時間当たり収益 | Revenue/h</div>
                    <div className="text-xs text-gray-500 mt-1">1時間の作業で得られる収益</div>
                  </div>
                  
                  {/* ROI */}
                  <div className="bg-white border border-yellow-200 rounded-lg p-4 shadow-sm">
                    <div className="flex items-center justify-between mb-2">
                      <div className="w-10 h-10 bg-yellow-100 rounded-full flex items-center justify-center">
                        <Award className="w-5 h-5 text-yellow-600" />
                      </div>
                      <div className="text-xs text-yellow-600 font-medium px-2 py-1 bg-yellow-50 rounded">
                        投資効率
                      </div>
                    </div>
                    <div className="text-2xl font-bold text-yellow-700 mb-1">
                      {selectedMonth.monthly_total_cost > 0 ? 
                        (((selectedMonth.monthly_total_revenue - selectedMonth.monthly_total_cost) / selectedMonth.monthly_total_cost) * 100).toFixed(1) : 0}%
                    </div>
                    <div className="text-sm text-gray-600">投資収益率 | ROI</div>
                    <div className="text-xs text-gray-500 mt-1">コストに対する利益率</div>
                  </div>
                </div>
              </div>

              {/* 作業種別詳細分析 */}
              <div className="bg-white border border-gray-200 rounded-lg shadow-sm">
                <div className="bg-gradient-to-r from-slate-50 to-indigo-50 px-6 py-4 border-b border-gray-200 rounded-t-lg">
                  <h3 className="text-lg font-bold text-gray-800 flex items-center gap-2">
                    🛠️ 作業種別効率分析
                    <div className="ml-auto px-3 py-1 bg-indigo-100 text-indigo-700 text-xs font-medium rounded-full">
                      Work Type Efficiency Analysis
                    </div>
                  </h3>
                  <p className="text-sm text-gray-600 mt-1">各作業における時間効率とROI分析</p>
                </div>
                
                <div className="p-6">
                  <div className="space-y-4">
                    {Object.entries(selectedMonth.work_types)
                      .filter(([_, data]) => data.total_hours > 0)
                      .sort(([,a], [,b]) => b.total_hours - a.total_hours)
                      .map(([workType, data], index) => (
                        <div key={workType} className="bg-gradient-to-r from-gray-50 to-indigo-50 border border-gray-200 rounded-lg p-4">
                          {/* 作業種別ヘッダー */}
                          <div className="flex items-center justify-between mb-4">
                            <div className="flex items-center gap-3">
                              <div 
                                className="w-8 h-8 rounded-lg flex items-center justify-center text-white font-bold text-sm shadow-sm"
                                style={{ backgroundColor: WORK_TYPE_COLORS[workType as keyof typeof WORK_TYPE_COLORS] }}
                              >
                                {(index + 1).toString().padStart(2, '0')}
                              </div>
                              <div>
                                <h4 className="font-bold text-gray-800">
                                  {WORK_TYPE_LABELS[workType as keyof typeof WORK_TYPE_LABELS]}
                                </h4>
                                <p className="text-xs text-gray-500">作業回数: {data.work_count}回</p>
                              </div>
                            </div>
                            <div className="text-right">
                              <div className={`inline-flex items-center px-3 py-1 rounded-full text-sm font-bold ${
                                data.efficiency_score >= 80 ? 'bg-green-100 text-green-800' :
                                data.efficiency_score >= 60 ? 'bg-blue-100 text-blue-800' :
                                data.efficiency_score >= 40 ? 'bg-yellow-100 text-yellow-800' :
                                'bg-red-100 text-red-800'
                              }`}>
                                効率: {data.efficiency_score.toFixed(1)}点
                              </div>
                            </div>
                          </div>
                          
                          {/* 効率指標 */}
                          <div className="grid grid-cols-3 gap-4 mb-4">
                            <div className="bg-white border border-gray-200 rounded-lg p-3 text-center">
                              <div className="text-lg font-bold text-indigo-700">{data.total_hours.toFixed(1)}h</div>
                              <div className="text-xs text-gray-600">総作業時間</div>
                            </div>
                            
                            <div className="bg-white border border-gray-200 rounded-lg p-3 text-center">
                              <div className="text-lg font-bold text-green-700">¥{Math.round(data.revenue_per_hour)}</div>
                              <div className="text-xs text-gray-600">時間当たり収益</div>
                            </div>
                            
                            <div className="bg-white border border-gray-200 rounded-lg p-3 text-center">
                              <div className={`text-lg font-bold ${data.roi_per_hour > 0 ? 'text-blue-700' : 'text-red-700'}`}>
                                {(data.roi_per_hour * 100).toFixed(1)}%
                              </div>
                              <div className="text-xs text-gray-600">時間当たりROI</div>
                            </div>
                          </div>
                          
                          {/* 作業詳細 */}
                          {data.details.length > 0 && (
                            <div className="mt-4 pt-4 border-t border-gray-300">
                              <div className="flex items-center justify-between mb-3">
                                <h5 className="text-sm font-bold text-gray-700 flex items-center gap-2">
                                  📋 作業実績詳細
                                  <span className="px-2 py-1 bg-gray-100 text-gray-600 text-xs rounded-full">
                                    {data.details.length}件
                                  </span>
                                </h5>
                              </div>
                              <div className="max-h-40 overflow-y-auto space-y-2 bg-white border border-gray-200 rounded-lg p-3">
                                {data.details.slice(0, 5).map((detail, detailIndex) => (
                                  <div key={detail.id} className="bg-gray-50 border border-gray-200 rounded-lg p-3 text-xs">
                                    <div className="flex justify-between items-start mb-2">
                                      <div className="font-medium text-gray-800 flex items-center gap-2">
                                        <span className={`w-5 h-5 rounded text-center text-xs leading-5 ${
                                          detail.efficiency_rating === 'excellent' ? 'bg-green-100 text-green-600' :
                                          detail.efficiency_rating === 'good' ? 'bg-blue-100 text-blue-600' :
                                          detail.efficiency_rating === 'average' ? 'bg-yellow-100 text-yellow-600' :
                                          'bg-red-100 text-red-600'
                                        }`}>
                                          {detailIndex + 1}
                                        </span>
                                        {new Date(detail.work_date).toLocaleDateString('ja-JP')}
                                      </div>
                                      <div className="text-right">
                                        <div className="font-bold text-indigo-700 text-sm">{detail.duration_hours.toFixed(1)}h</div>
                                        <div className="text-xs text-gray-500">
                                          ROI: {detail.cost_incurred > 0 ? 
                                            (((detail.revenue_generated - detail.cost_incurred) / detail.cost_incurred) * 100).toFixed(1) : 
                                            0}%
                                        </div>
                                      </div>
                                    </div>
                                    
                                    <div className="grid grid-cols-2 gap-2 text-gray-600">
                                      <div className="flex items-center gap-1">
                                        <span className="text-green-600">💰</span>
                                        収益: ¥{Math.round(detail.revenue_generated)}
                                      </div>
                                      <div className="flex items-center gap-1">
                                        <span className="text-red-600">💸</span>
                                        コスト: ¥{Math.round(detail.cost_incurred)}
                                      </div>
                                    </div>
                                    
                                    {detail.description && (
                                      <div className="mt-2 text-gray-500 text-xs italic border-l-2 border-gray-300 pl-2">
                                        💭 {detail.description}
                                      </div>
                                    )}
                                  </div>
                                ))}
                                {data.details.length > 5 && (
                                  <div className="text-center text-gray-500 text-xs py-2">
                                    他 {data.details.length - 5} 件の作業実績があります
                                  </div>
                                )}
                              </div>
                            </div>
                          )}
                        </div>
                      ))}
                  </div>
                </div>
              </div>
            </div>
          )}
          
          {/* 閉じるボタン */}
          <div className="flex justify-center pt-6 mt-6 border-t border-gray-200 bg-gradient-to-t from-gray-50 to-white -mx-6 -mb-6 px-6 pb-6 rounded-b-lg">
            <DialogPrimitive.Close asChild>
              <Button 
                variant="outline" 
                className="flex items-center gap-2 px-8 py-3 text-gray-700 border-gray-300 hover:bg-gray-50 hover:border-gray-400 transition-all duration-200 font-medium"
              >
                <X className="w-4 h-4" />
                分析レポートを閉じる
              </Button>
            </DialogPrimitive.Close>
          </div>
        </LargeDialogContent>
      </Dialog>
    </>
  )
}